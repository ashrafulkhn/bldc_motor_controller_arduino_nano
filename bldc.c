//************************************************************************************
//**  
//**  Source name:   C:\Users\youteknovation\Documents\Arduino\bldc\bldc.fcfx
//**  Title:         
//**  Description:   
//**  Device:        AVR.ATMEGA.ATMEGA328P
//**  
//**  Generated by:  Flowcode v6.1.3.2
//**  Date:          Thursday, August 09, 2018 18:56:02
//**  Users:         -1
//**  Registered to: 88263627
//**  Licence key:   K38DMR
//**  
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  http://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_AVR
#define MX_CAL_AVR
#define MX_CLK_SPEED 16000000
#define FCP_NULL Unconnected_Port
#define MX_UART_ID
#define MX_UART_UCSRC

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <avr\io.h>
#include <avr\interrupt.h>
#include <avr\eeprom.h>
#include <avr\wdt.h>


/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\internals.c"

MX_UINT8 FCLV_LOOP1;


/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_SPEED = (0x0);
MX_GLOBAL MX_BOOL FCV_START = (0);
MX_GLOBAL MX_UINT16 FCV_SENSC = (0x0);
MX_GLOBAL MX_UINT16 FCV_SENSB = (0x0);
MX_GLOBAL MX_UINT16 FCV_SENSA = (0x0);

void FCM_fase6();
void FCM_fase5();
void FCM_fase4();
void FCM_fase3();
void FCM_fase2();
void FCM_getHallSensor();
void FCM_fase1();
void FCM_jumpStart();
void FCM_setSpeed();
void FCM_cekfase6();
void FCM_cekfase5();
void FCM_cekfase4();
void FCM_cekfase3();
void FCM_cekfase2();
void FCM_cekfase1();

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_4_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_4_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_3 
#define MX_ADC_TYPE_2 
#define ADC_4_MX_ADC_VREFOP 0
#define ADC_4_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_4_MX_ADC_CHANNEL 3

#define FCV_0aae4_cal_adc__FALSE (0)
#define FCV_0aae4_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f44_adc_base__RawSampleInt();
MX_UINT8 FCD_08f44_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f44_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f44_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f44_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f44_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f44_adc_base__GetVoltage();
void FCD_08f44_adc_base__RawEnable();
MX_UINT8 FCD_08f44_adc_base__RawSampleByte();
MX_UINT16 FCD_08f44_adc_base__GetInt();
void FCD_08f44_adc_base__RawDisable();
MX_UINT8 FCD_08f44_adc_base__GetByte();

/*========================================================================*\
   Use :speedCon
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0d101_speedCon__RawSampleInt FCD_08f44_adc_base__RawSampleInt
#define FCD_0d101_speedCon__RawAverageByte FCD_08f44_adc_base__RawAverageByte
#define FCD_0d101_speedCon__GetString FCD_08f44_adc_base__GetString
#define FCD_0d101_speedCon__GetAverageByte FCD_08f44_adc_base__GetAverageByte
#define FCD_0d101_speedCon__RawAverageInt FCD_08f44_adc_base__RawAverageInt
#define FCD_0d101_speedCon__GetAverageInt FCD_08f44_adc_base__GetAverageInt
#define FCD_0d101_speedCon__GetVoltage FCD_08f44_adc_base__GetVoltage
#define FCD_0d101_speedCon__RawEnable FCD_08f44_adc_base__RawEnable
#define FCD_0d101_speedCon__RawSampleByte FCD_08f44_adc_base__RawSampleByte
#define FCD_0d101_speedCon__GetInt FCD_08f44_adc_base__GetInt
#define FCD_0d101_speedCon__RawDisable FCD_08f44_adc_base__RawDisable
#define FCD_0d101_speedCon__GetByte FCD_08f44_adc_base__GetByte

/*========================================================================*\
   Use :bezel_radiused1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb8_ASCII6__FLOATFIXEDLIST 1
#define FCVsz_00fb8_ASCII6__INTLIST 60
#define FCVsz_00fb8_ASCII6__FLOATLIST 1
#define FCVsz_00fb8_ASCII6__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII7
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb7_ASCII7__FLOATFIXEDLIST 1
#define FCVsz_00fb7_ASCII7__INTLIST 55
#define FCVsz_00fb7_ASCII7__FLOATLIST 1
#define FCVsz_00fb7_ASCII7__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb6_ASCII5__FLOATFIXEDLIST 1
#define FCVsz_00fb6_ASCII5__INTLIST 60
#define FCVsz_00fb6_ASCII5__FLOATLIST 1
#define FCVsz_00fb6_ASCII5__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb5_ASCII4__FLOATFIXEDLIST 1
#define FCVsz_00fb5_ASCII4__INTLIST 60
#define FCVsz_00fb5_ASCII4__FLOATLIST 1
#define FCVsz_00fb5_ASCII4__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb4_ASCII3__FLOATFIXEDLIST 1
#define FCVsz_00fb4_ASCII3__INTLIST 60
#define FCVsz_00fb4_ASCII3__FLOATLIST 1
#define FCVsz_00fb4_ASCII3__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb3_ASCII2__FLOATFIXEDLIST 1
#define FCVsz_00fb3_ASCII2__INTLIST 60
#define FCVsz_00fb3_ASCII2__FLOATLIST 1
#define FCVsz_00fb3_ASCII2__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb2_ASCII1__FLOATFIXEDLIST 1
#define FCVsz_00fb2_ASCII1__INTLIST 60
#define FCVsz_00fb2_ASCII1__FLOATLIST 1
#define FCVsz_00fb2_ASCII1__INTFIXEDLIST 1


/*========================================================================*\
   Use :ASCII0
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCVsz_00fb1_ASCII0__FLOATFIXEDLIST 1
#define FCVsz_00fb1_ASCII0__INTLIST 60
#define FCVsz_00fb1_ASCII0__FLOATLIST 1
#define FCVsz_00fb1_ASCII0__INTFIXEDLIST 1


/*========================================================================*\
   Use :PWM_Digital
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT);

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define MX_PWM_REF1 
#define MX_PWM_PRESCALE1 (8)
#define MX_PWM_PIN_1 (6)
#define MX_PWM_PORT_1 portd
#define MX_PWM_PERIOD 255
#define MX_PWM_TRIS_1 trisd
#define MX_PWM_CHANNEL_1 (1)


/*=----------------------------------------------------------------------=*\
   Use :cal_pwm
       :Supplementary defines
\*=----------------------------------------------------------------------=*/
#define MX_PWM
#define MX_PWM_TMR0_CNT 2
#define MX_PWM_TMR1_CNT 2
#define MX_PWM_TMR2_CNT 2
#define MX_PWM_TMR3_CNT 0
#define MX_PWM_TMR4_CNT 0
#define MX_PWM_TMR5_CNT 0
#define MX_PWM_CNT 6

void FC_CAL_PWM_ChangePeriod_1(MX_UINT16 FCL_PERIOD, MX_UINT16 FCL_PRESCALER);
void FC_CAL_PWM_Disable_1();
void FC_CAL_PWM_SetDuty8Bit_1(MX_UINT8 FCL_DUTY);
void FC_CAL_PWM_Enable_1();
void FC_CAL_PWM_SetDuty10Bit_1(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :pwmSpeed
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_GLOBAL MX_UINT8 FCV_0df41_pwmSpeed__ENABLED = (0x0);

void FCD_0df41_pwmSpeed__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER);
void FCD_0df41_pwmSpeed__Disable();
void FCD_0df41_pwmSpeed__SetDutyCycle(MX_UINT8 FCL_DUTY);
void FCD_0df41_pwmSpeed__Enable();
void FCD_0df41_pwmSpeed__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY);

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d92_led_base1__TurnOn();
void FCD_03d92_led_base1__TurnOff();

/*========================================================================*\
   Use :default_target
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083d2_default_target__TurnOn FCD_03d92_led_base1__TurnOn
#define FCD_083d2_default_target__TurnOff FCD_03d92_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d910_led_base1__TurnOn();
void FCD_03d910_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm6
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083d10_led_5mm6__TurnOn FCD_03d910_led_base1__TurnOn
#define FCD_083d10_led_5mm6__TurnOff FCD_03d910_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d9f_led_base1__TurnOn();
void FCD_03d9f_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm5
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083df_led_5mm5__TurnOn FCD_03d9f_led_base1__TurnOn
#define FCD_083df_led_5mm5__TurnOff FCD_03d9f_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d9e_led_base1__TurnOn();
void FCD_03d9e_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm4
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083de_led_5mm4__TurnOn FCD_03d9e_led_base1__TurnOn
#define FCD_083de_led_5mm4__TurnOff FCD_03d9e_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d9d_led_base1__TurnOn();
void FCD_03d9d_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm3
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083dd_led_5mm3__TurnOn FCD_03d9d_led_base1__TurnOn
#define FCD_083dd_led_5mm3__TurnOff FCD_03d9d_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d9c_led_base1__TurnOn();
void FCD_03d9c_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm2
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083dc_led_5mm2__TurnOn FCD_03d9c_led_base1__TurnOn
#define FCD_083dc_led_5mm2__TurnOff FCD_03d9c_led_base1__TurnOff

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d9b_led_base1__TurnOn();
void FCD_03d9b_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083db_led_5mm1__TurnOn FCD_03d9b_led_base1__TurnOn
#define FCD_083db_led_5mm1__TurnOff FCD_03d9b_led_base1__TurnOff

/*========================================================================*\
   Use :led_array1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_0e1e1_led_array1__BarGraph(MX_UINT8 FCL_LENGTH);
void FCD_0e1e1_led_array1__LEDOn(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__AllOn();
void FCD_0e1e1_led_array1__LEDOff(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__PointGraph(MX_UINT8 FCL_INDEX);
void FCD_0e1e1_led_array1__WriteValue(MX_UINT8 FCL_VALUE);
void FCD_0e1e1_led_array1__AllOff();

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d91_led_base1__TurnOn();
void FCD_03d91_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083d1_led_5mm1__TurnOn FCD_03d91_led_base1__TurnOn
#define FCD_083d1_led_5mm1__TurnOff FCD_03d91_led_base1__TurnOff

/*========================================================================*\
   Use :mosfetDriver
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0a331_mosfetDriver__BarGraph FCD_0e1e1_led_array1__BarGraph
#define FCD_0a331_mosfetDriver__LEDOn FCD_0e1e1_led_array1__LEDOn
#define FCD_0a331_mosfetDriver__AllOn FCD_0e1e1_led_array1__AllOn
#define FCD_0a331_mosfetDriver__LEDOff FCD_0e1e1_led_array1__LEDOff
#define FCD_0a331_mosfetDriver__PointGraph FCD_0e1e1_led_array1__PointGraph
#define FCD_0a331_mosfetDriver__WriteValue FCD_0e1e1_led_array1__WriteValue
#define FCD_0a331_mosfetDriver__AllOff FCD_0e1e1_led_array1__AllOff

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_3_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_3_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_2 
#define MX_ADC_TYPE_2 
#define ADC_3_MX_ADC_VREFOP 0
#define ADC_3_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_3_MX_ADC_CHANNEL 2

#define FCV_0aae3_cal_adc__FALSE (0)
#define FCV_0aae3_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f43_adc_base__RawSampleInt();
MX_UINT8 FCD_08f43_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f43_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f43_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f43_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f43_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f43_adc_base__GetVoltage();
void FCD_08f43_adc_base__RawEnable();
MX_UINT8 FCD_08f43_adc_base__RawSampleByte();
MX_UINT16 FCD_08f43_adc_base__GetInt();
void FCD_08f43_adc_base__RawDisable();
MX_UINT8 FCD_08f43_adc_base__GetByte();

/*========================================================================*\
   Use :HallC
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03523_HallC__RawSampleInt FCD_08f43_adc_base__RawSampleInt
#define FCD_03523_HallC__RawAverageByte FCD_08f43_adc_base__RawAverageByte
#define FCD_03523_HallC__GetString FCD_08f43_adc_base__GetString
#define FCD_03523_HallC__GetAverageByte FCD_08f43_adc_base__GetAverageByte
#define FCD_03523_HallC__RawAverageInt FCD_08f43_adc_base__RawAverageInt
#define FCD_03523_HallC__GetAverageInt FCD_08f43_adc_base__GetAverageInt
#define FCD_03523_HallC__GetVoltage FCD_08f43_adc_base__GetVoltage
#define FCD_03523_HallC__RawEnable FCD_08f43_adc_base__RawEnable
#define FCD_03523_HallC__RawSampleByte FCD_08f43_adc_base__RawSampleByte
#define FCD_03523_HallC__GetInt FCD_08f43_adc_base__GetInt
#define FCD_03523_HallC__RawDisable FCD_08f43_adc_base__RawDisable
#define FCD_03523_HallC__GetByte FCD_08f43_adc_base__GetByte

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_2_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_2_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_1 
#define MX_ADC_TYPE_2 
#define ADC_2_MX_ADC_VREFOP 0
#define ADC_2_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_2_MX_ADC_CHANNEL 1

#define FCV_0aae2_cal_adc__FALSE (0)
#define FCV_0aae2_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt();
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f42_adc_base__GetVoltage();
void FCD_08f42_adc_base__RawEnable();
MX_UINT8 FCD_08f42_adc_base__RawSampleByte();
MX_UINT16 FCD_08f42_adc_base__GetInt();
void FCD_08f42_adc_base__RawDisable();
MX_UINT8 FCD_08f42_adc_base__GetByte();

/*========================================================================*\
   Use :HallB
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03522_HallB__RawSampleInt FCD_08f42_adc_base__RawSampleInt
#define FCD_03522_HallB__RawAverageByte FCD_08f42_adc_base__RawAverageByte
#define FCD_03522_HallB__GetString FCD_08f42_adc_base__GetString
#define FCD_03522_HallB__GetAverageByte FCD_08f42_adc_base__GetAverageByte
#define FCD_03522_HallB__RawAverageInt FCD_08f42_adc_base__RawAverageInt
#define FCD_03522_HallB__GetAverageInt FCD_08f42_adc_base__GetAverageInt
#define FCD_03522_HallB__GetVoltage FCD_08f42_adc_base__GetVoltage
#define FCD_03522_HallB__RawEnable FCD_08f42_adc_base__RawEnable
#define FCD_03522_HallB__RawSampleByte FCD_08f42_adc_base__RawSampleByte
#define FCD_03522_HallB__GetInt FCD_08f42_adc_base__GetInt
#define FCD_03522_HallB__RawDisable FCD_08f42_adc_base__RawDisable
#define FCD_03522_HallB__GetByte FCD_08f42_adc_base__GetByte

/*========================================================================*\
   Use :fcdhelper
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define ADC_1_MX_ADC_ACTIME 40
#define MX_ADC_REF 
#define ADC_1_MX_ADC_VREFVOL 500
#define MX_ADC_CHANNEL_0 
#define MX_ADC_TYPE_2 
#define ADC_1_MX_ADC_VREFOP 0
#define ADC_1_MX_ADC_CONVSP 3
#define MX_ADC_BITS_10 
#define ADC_1_MX_ADC_CHANNEL 0

#define FCV_0aae1_cal_adc__FALSE (0)
#define FCV_0aae1_cal_adc__TRUE (1)

void FC_CAL_ADC_Disable();
void FC_CAL_ADC_Enable(MX_UINT8 FCL_CHANNEL, MX_UINT8 FCL_CONV_SPEED, MX_UINT8 FCL_VREF, MX_UINT8 FCL_T_CHARGE);
MX_UINT16 FC_CAL_ADC_Sample(MX_UINT8 FCL_SAMPLE_MODE);

/*========================================================================*\
   Use :adc_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt();
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL);
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS);
MX_FLOAT FCD_08f41_adc_base__GetVoltage();
void FCD_08f41_adc_base__RawEnable();
MX_UINT8 FCD_08f41_adc_base__RawSampleByte();
MX_UINT16 FCD_08f41_adc_base__GetInt();
void FCD_08f41_adc_base__RawDisable();
MX_UINT8 FCD_08f41_adc_base__GetByte();

/*========================================================================*\
   Use :hallA
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_03521_hallA__RawSampleInt FCD_08f41_adc_base__RawSampleInt
#define FCD_03521_hallA__RawAverageByte FCD_08f41_adc_base__RawAverageByte
#define FCD_03521_hallA__GetString FCD_08f41_adc_base__GetString
#define FCD_03521_hallA__GetAverageByte FCD_08f41_adc_base__GetAverageByte
#define FCD_03521_hallA__RawAverageInt FCD_08f41_adc_base__RawAverageInt
#define FCD_03521_hallA__GetAverageInt FCD_08f41_adc_base__GetAverageInt
#define FCD_03521_hallA__GetVoltage FCD_08f41_adc_base__GetVoltage
#define FCD_03521_hallA__RawEnable FCD_08f41_adc_base__RawEnable
#define FCD_03521_hallA__RawSampleByte FCD_08f41_adc_base__RawSampleByte
#define FCD_03521_hallA__GetInt FCD_08f41_adc_base__GetInt
#define FCD_03521_hallA__RawDisable FCD_08f41_adc_base__RawDisable
#define FCD_03521_hallA__GetByte FCD_08f41_adc_base__GetByte

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\Program Files (x86)\Flowcode 6\CAL\includes.c"


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f44_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f44_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f44_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f44_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f44_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(3, 3, 0, 40);

	FCR_RETVAL = FCD_08f44_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f44_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f44_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(3, 3, 0, 40);

	FCR_RETVAL = FCD_08f44_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f44_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(3, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f44_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(3, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f44_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f44_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(3, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f44_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f44_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(3, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :speedCon
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :bezel_radiused1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :scale_linear
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :dash_scale_vert1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII7
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ASCII0
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :PWM_Digital
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Gets a byte of the embedded ASCII font data.
       :
       :Parameters for macro ReadASCIILUT:
       :  pos_str : ASCII position -32 so A = 'A' - 32 = 33
       :  count : Font column Ranging 0-4
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_0ba71_PWM_Digital__ReadASCIILUT(MX_UINT8 FCL_POS_STR, MX_UINT8 FCL_COUNT)
{
	//Local variable definitions
	MX_UINT8 FCL_POSITION;
	MX_UINT8 FCR_RETVAL;


	#if (0) // 0 == 1

	//Code has been optimised out by the pre-processor
	// #else

	#endif

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_pwm
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :pwmSpeed
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Sets the overall period and prescaler of the output PWM signal.
       :
       :Parameters for macro ChangePeriod:
       :  Period : The maximum number that will represent 100% on, PIC/AVR: 0-255 16-bit PIC: 0-65535
       :  Prescaler : The scaler used to divide the system clock speed down to the PWM rate.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_pwmSpeed__ChangePeriod(MX_UINT16 FCL_PERIOD, MX_SINT16 FCL_PRESCALER)
{

	FC_CAL_PWM_ChangePeriod_1(FCL_PERIOD, FCL_PRESCALER);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables a PWM channel and allows the default output / input state to be resumed
\*=----------------------------------------------------------------------=*/
void FCD_0df41_pwmSpeed__Disable()
{

	FCV_0df41_pwmSpeed__ENABLED = 0;

	FC_CAL_PWM_Disable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :Sets the PWM duty cycle in terms of on/off based on the current period setting.
       :E.g. if period = 255 then duty of 128 is equal to 50% on and 50% off.
       :16-bit PIC users should use the 10bit duty function to access the full range.
       :
       :Parameters for macro SetDutyCycle:
       :  Duty : 8-bit PWM duty 0-255
\*=----------------------------------------------------------------------=*/
void FCD_0df41_pwmSpeed__SetDutyCycle(MX_UINT8 FCL_DUTY)
{

	if (FCV_0df41_pwmSpeed__ENABLED)
	{

		FC_CAL_PWM_SetDuty8Bit_1(FCL_DUTY);

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :Enables a PWM channel as an output overriding the default output pin state.
\*=----------------------------------------------------------------------=*/
void FCD_0df41_pwmSpeed__Enable()
{

	FCV_0df41_pwmSpeed__ENABLED = 1;

	FC_CAL_PWM_ChangePeriod_1(255, 8);

	FC_CAL_PWM_Enable_1();

}

/*=----------------------------------------------------------------------=*\
   Use :PIC/AVR - Sets the full scale PWM duty cycle based on the current period setting.
       :If period = 255 then Duty of 512 is equal to 50%.
       :
       :16-bit PICs have a 16-bit period range available.
       :If period = 65535 then Duty of 32768 is equal to 50%.
       :
       :Parameters for macro SetDutyCycle10Bit:
       :  Duty : PWM duty PIC/AVR: 0-1023 16-bit PIC: 0-65535
\*=----------------------------------------------------------------------=*/
void FCD_0df41_pwmSpeed__SetDutyCycle10Bit(MX_UINT16 FCL_DUTY)
{

	if (FCV_0df41_pwmSpeed__ENABLED)
	{

		FC_CAL_PWM_SetDuty10Bit_1(FCL_DUTY);

	// } else {

	}

}


/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d92_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :default_target
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d910_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x20, 0x5, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d910_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x20, 0x5, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm6
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9f_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x10, 0x4, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9f_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x10, 0x4, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm5
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9e_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x8, 0x3, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9e_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x8, 0x3, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm4
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9d_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x4, 0x2, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9d_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x4, 0x2, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm3
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9c_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x2, 0x1, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9c_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x2, 0x1, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm2
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d9b_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d9b_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_array1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turns on the first N elements of the array - for generating bar graph metes etc.
       :
       :Parameters for macro BarGraph:
       :  Length : How many items to light up.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__BarGraph(MX_UINT8 FCL_LENGTH)
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	FCL_INDEX = 0;

	while (FCL_INDEX < 6)
	{

		if (FCL_INDEX >= FCL_LENGTH)
		{

			FCD_0e1e1_led_array1__LEDOff(FCL_INDEX);

		} else {

			FCD_0e1e1_led_array1__LEDOn(FCL_INDEX);

		}

		FCL_INDEX = FCL_INDEX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turn on the selected LED.
       :
       :Parameters for macro LEDOn:
       :  Index : Index of the LED to turn on.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__LEDOn(MX_UINT8 FCL_INDEX)
{

	switch (FCL_INDEX)
	{
		case 0:
		{
			#if (1) // 6 > 0

				FCP_SET(B, B, 0x1, 0x0, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 1:
		{
			#if (1) // 6 > 1

				FCP_SET(B, B, 0x2, 0x1, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 6 > 2

				FCP_SET(B, B, 0x4, 0x2, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 6 > 3

				FCP_SET(B, B, 0x8, 0x3, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 6 > 4

				FCP_SET(B, B, 0x10, 0x4, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 6 > 5

				FCP_SET(B, B, 0x20, 0x5, 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 6:
		{
			#if (0) // 6 > 6

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			break;
		}
		case 7:
		{
			#if (0) // 6 > 7

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			break;
		}
		default:
		{
		}
	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns on all elements
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__AllOn()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	#if (0) // 1 == 11

	//Code has been optimised out by the pre-processor
	#else

		#if (1) // 1 == 1

			FCP_SET(F, B, 0xff, 0x0, 63);

		#else

		//Code has been optimised out by the pre-processor
		#endif

	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Turn off the selected led.
       :
       :Parameters for macro LEDOff:
       :  Index : Index of the LED to turn on.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__LEDOff(MX_UINT8 FCL_INDEX)
{

	switch (FCL_INDEX)
	{
		case 0:
		{
			#if (1) // 6 > 0

				FCP_SET(B, B, 0x1, 0x0, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 1:
		{
			#if (1) // 6 > 1

				FCP_SET(B, B, 0x2, 0x1, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 2:
		{
			#if (1) // 6 > 2

				FCP_SET(B, B, 0x4, 0x2, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 3:
		{
			#if (1) // 6 > 3

				FCP_SET(B, B, 0x8, 0x3, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 4:
		{
			#if (1) // 6 > 4

				FCP_SET(B, B, 0x10, 0x4, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 5:
		{
			#if (1) // 6 > 5

				FCP_SET(B, B, 0x20, 0x5, 1 - 1);

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			break;
		}
		case 6:
		{
			#if (0) // 6 > 6

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			break;
		}
		case 7:
		{
			#if (0) // 6 > 7

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			break;
		}
		default:
		{
		}
	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns on the Indexed LED and turns all others off.
       :Does nothing if the index is out of range.
       :
       :Parameters for macro PointGraph:
       :  Index : The LED to show.
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__PointGraph(MX_UINT8 FCL_INDEX)
{
	//Local variable definitions
	MX_UINT8 FCL_IDX;


	FCL_IDX = 0;

	while (FCL_IDX < 6)
	{

		if (FCL_IDX == FCL_INDEX)
		{

			FCD_0e1e1_led_array1__LEDOn(FCL_IDX);

		} else {

			FCD_0e1e1_led_array1__LEDOff(FCL_IDX);

		}

		FCL_IDX = FCL_IDX + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Write a number which is presented on the LEDs in binary.
       :
       :Parameters for macro WriteValue:
       :  Value : Provide a value to be written to the LEDs in binary
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__WriteValue(MX_UINT8 FCL_VALUE)
{
	//Local variable definitions
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCL_TEMPVALUE = (0);
	MX_UINT16 FCL_MASK = (0x0);


	FCL_COUNT = 0;

	while (FCL_COUNT < 6)
	{

		if (FCL_VALUE & (1 << FCL_COUNT))
		{

			FCD_0e1e1_led_array1__LEDOn(FCL_COUNT);

		} else {

			FCD_0e1e1_led_array1__LEDOff(FCL_COUNT);

		}

		FCL_COUNT = FCL_COUNT + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Turns off all elements
\*=----------------------------------------------------------------------=*/
void FCD_0e1e1_led_array1__AllOff()
{
	//Local variable definitions
	MX_UINT8 FCL_INDEX;


	#if (0) // 1 == 11

	//Code has been optimised out by the pre-processor
	#else

		#if (1) // 1 == 1

			FCP_SET(F, B, 0xff, 0x0, ~63);

		#else

		//Code has been optimised out by the pre-processor
		#endif

	#endif

}


/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOn()
{

	FCP_SET(B, B, 0x1, 0x0, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOff()
{

	FCP_SET(B, B, 0x1, 0x0, 1 - 1);

}


/*========================================================================*\
   Use :led_5mm1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :mosfetDriver
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f43_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f43_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f43_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f43_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f43_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(2, 3, 0, 40);

	FCR_RETVAL = FCD_08f43_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f43_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f43_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(2, 3, 0, 40);

	FCR_RETVAL = FCD_08f43_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f43_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(2, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f43_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(2, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f43_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f43_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(2, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f43_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f43_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(2, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :HallC
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f42_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(1, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f42_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(1, 3, 0, 40);

	FCR_RETVAL = FCD_08f42_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f42_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(1, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(1, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f42_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(1, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f42_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f42_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(1, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :HallB
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :fcdhelper
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :cal_adc
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :adc_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC at full bit depth
       :Call Enable() first
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__RawSampleInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_UINT8 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(0);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage and returns as as tring
       :
       :Returns : MX_CHAR
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__GetString(MX_CHAR *FCR_RETVAL, MX_UINT16 FCRsz_RETVAL)
{
	//Local variable definitions
	MX_FLOAT FCL_SAMPLE;


	FCL_SAMPLE = FCD_08f41_adc_base__GetVoltage();

	FCI_FLOAT_TO_STRING(FCL_SAMPLE, FCV_PRECISION, FCR_RETVAL,20);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a byte average sample over time
       :
       :Parameters for macro GetAverageByte:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetAverageByte(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(0, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageByte(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a full width average sample over time
       :Call Enable() before this
       :
       :Parameters for macro RawAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : MX_UINT8
       :
       :Returns : MX_SINT16
\*=----------------------------------------------------------------------=*/
MX_SINT16 FCD_08f41_adc_base__RawAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT32 FCL_AVERAGE = (0x0);
	MX_UINT8 FCL_COUNT = (0x0);
	MX_SINT16 FCR_RETVAL;


	if (FCL_DELAYUS > 0)
	{

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;

			FCI_DELAYBYTE_US(FCL_DELAYUS);


		}

	} else {

		while (FCL_COUNT < FCL_NUMSAMPLES)
		{

			FCL_AVERAGE = FCL_AVERAGE + FC_CAL_ADC_Sample(1);
			FCL_COUNT = FCL_COUNT + 1;


		}

	}

	FCR_RETVAL = FCL_AVERAGE / FCL_COUNT;

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Function call to read the ADC as a full width average sample over time
       :
       :Parameters for macro GetAverageInt:
       :  NumSamples : MX_UINT8
       :  DelayUs : Number of micro seconds in between taking each sample
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetAverageInt(MX_UINT8 FCL_NUMSAMPLES, MX_UINT8 FCL_DELAYUS)
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(0, 3, 0, 40);

	FCR_RETVAL = FCD_08f41_adc_base__RawAverageInt(FCL_NUMSAMPLES, FCL_DELAYUS);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Reads the ADC as a direct voltage
       :
       :Returns : MX_FLOAT
\*=----------------------------------------------------------------------=*/
MX_FLOAT FCD_08f41_adc_base__GetVoltage()
{
	//Local variable definitions
	MX_UINT16 FCL_SAMPLE;
	MX_FLOAT FCR_RETVAL;


	FC_CAL_ADC_Enable(0, 3, 0, 40);

	FCL_SAMPLE = FC_CAL_ADC_Sample(1);

	FCR_RETVAL = flt_mul(flt_fromi(FCL_SAMPLE), 0.004883);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Enables and configures the ADC channel to be an analogue input.
       :Only one ADC channel can be enabled at a time. Any RAW functions will reference the last enabled channel only.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawEnable()
{

	FC_CAL_ADC_Enable(0, 3, 0, 40);

}

/*=----------------------------------------------------------------------=*\
   Use :Background call to read the ADC as a byte
       :Call Enable() before this
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__RawSampleByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC at full bit depth
       :
       :Returns : MX_UINT16
\*=----------------------------------------------------------------------=*/
MX_UINT16 FCD_08f41_adc_base__GetInt()
{
	//Local variable definitions
	MX_UINT16 FCR_RETVAL;


	FC_CAL_ADC_Enable(0, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(1);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Disables the previously enabled ADC channel and converts back to digital mode.
\*=----------------------------------------------------------------------=*/
void FCD_08f41_adc_base__RawDisable()
{

	FC_CAL_ADC_Disable();

}

/*=----------------------------------------------------------------------=*\
   Use :Blocking call to read the ADC as a byte
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_08f41_adc_base__GetByte()
{
	//Local variable definitions
	MX_UINT8 FCR_RETVAL;


	FC_CAL_ADC_Enable(0, 3, 0, 40);

	FCR_RETVAL = FC_CAL_ADC_Sample(0);

	FC_CAL_ADC_Disable();

	return (FCR_RETVAL);

}


/*========================================================================*\
   Use :hallA
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase6()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(0)
	FCD_0a331_mosfetDriver__LEDOff(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(1)
	FCD_0a331_mosfetDriver__LEDOn(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(2)
	FCD_0a331_mosfetDriver__LEDOff(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(3)
	FCD_0a331_mosfetDriver__LEDOff(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(4)
	FCD_0a331_mosfetDriver__LEDOn(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(5)
	FCD_0a331_mosfetDriver__LEDOff(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase5()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(0)
	FCD_0a331_mosfetDriver__LEDOff(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(1)
	FCD_0a331_mosfetDriver__LEDOn(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(2)
	FCD_0a331_mosfetDriver__LEDOn(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(3)
	FCD_0a331_mosfetDriver__LEDOff(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(4)
	FCD_0a331_mosfetDriver__LEDOff(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(5)
	FCD_0a331_mosfetDriver__LEDOff(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase4()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(0)
	FCD_0a331_mosfetDriver__LEDOff(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(1)
	FCD_0a331_mosfetDriver__LEDOff(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(2)
	FCD_0a331_mosfetDriver__LEDOn(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(3)
	FCD_0a331_mosfetDriver__LEDOff(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(4)
	FCD_0a331_mosfetDriver__LEDOff(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(5)
	FCD_0a331_mosfetDriver__LEDOn(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase3()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(0)
	FCD_0a331_mosfetDriver__LEDOn(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(1)
	FCD_0a331_mosfetDriver__LEDOff(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(2)
	FCD_0a331_mosfetDriver__LEDOff(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(3)
	FCD_0a331_mosfetDriver__LEDOff(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(4)
	FCD_0a331_mosfetDriver__LEDOff(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(5)
	FCD_0a331_mosfetDriver__LEDOn(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase2()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(0)
	FCD_0a331_mosfetDriver__LEDOn(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(1)
	FCD_0a331_mosfetDriver__LEDOff(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(2)
	FCD_0a331_mosfetDriver__LEDOff(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(3)
	FCD_0a331_mosfetDriver__LEDOn(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(4)
	FCD_0a331_mosfetDriver__LEDOff(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(5)
	FCD_0a331_mosfetDriver__LEDOff(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_getHallSensor()
{

	// Call Macro
	// Call Macro: setSpeed()
	FCM_setSpeed();

	// Call Component Macro
	// Call Component Macro: sensA=hallA::GetInt()
	FCV_SENSA = FCD_03521_hallA__GetInt();

	// Call Component Macro
	// Call Component Macro: sensB=HallB::GetInt()
	FCV_SENSB = FCD_03522_HallB__GetInt();

	// Call Component Macro
	// Call Component Macro: sensC=HallC::GetInt()
	FCV_SENSC = FCD_03523_HallC__GetInt();

	// Call Macro
	// Call Macro: cekfase1()
	FCM_cekfase1();

	// Call Macro
	// Call Macro: cekfase2()
	FCM_cekfase2();

	// Call Macro
	// Call Macro: cekfase3()
	FCM_cekfase3();

	// Call Macro
	// Call Macro: cekfase4()
	FCM_cekfase4();

	// Call Macro
	// Call Macro: cekfase5()
	FCM_cekfase5();

	// Call Macro
	// Call Macro: cekfase6()
	FCM_cekfase6();

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_fase1()
{

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(0)
	FCD_0a331_mosfetDriver__LEDOff(0);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(1)
	FCD_0a331_mosfetDriver__LEDOff(1);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(2)
	FCD_0a331_mosfetDriver__LEDOff(2);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(3)
	FCD_0a331_mosfetDriver__LEDOn(3);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOn(4)
	FCD_0a331_mosfetDriver__LEDOn(4);

	// Call Component Macro
	// Call Component Macro: mosfetDriver::LEDOff(5)
	FCD_0a331_mosfetDriver__LEDOff(5);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_jumpStart()
{

	// Call Component Macro
	// Call Component Macro: speed=speedCon::GetByte()
	FCV_SPEED = FCD_0d101_speedCon__GetByte();

	// Decision
	// Decision: speed > 5?
	if (FCV_SPEED > 5)
	{

		// Loop
		// Loop: While start = 0
		while (FCV_START == 0)
		{

			// Call Macro
			// Call Macro: setSpeed()
			FCM_setSpeed();

			// Call Macro
			// Call Macro: fase1()
			FCM_fase1();

			// Calculation
			// Calculation:
			//  start = 1
			FCV_START = 1;


		}

	} else {

		// Calculation
		// Calculation:
		//  start = 0
		FCV_START = 0;

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_setSpeed()
{

	// Call Component Macro
	// Call Component Macro: speed=speedCon::GetByte()
	FCV_SPEED = FCD_0d101_speedCon__GetByte();

	// Call Component Macro
	// Call Component Macro: pwmSpeed::SetDutyCycle(speed)
	FCD_0df41_pwmSpeed__SetDutyCycle(FCV_SPEED);

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase6()
{

	// Decision
	// Decision: sensA = 0?
	if (FCV_SENSA == 0)
	{

		// Decision
		// Decision: sensB = 0?
		if (FCV_SENSB == 0)
		{

			// Decision
			// Decision: sensC > 0?
			if (FCV_SENSC > 0)
			{

				// Call Macro
				// Call Macro: fase6()
				FCM_fase6();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase5()
{

	// Decision
	// Decision: sensA = 0?
	if (FCV_SENSA == 0)
	{

		// Decision
		// Decision: sensB > 0?
		if (FCV_SENSB > 0)
		{

			// Decision
			// Decision: sensC > 0?
			if (FCV_SENSC > 0)
			{

				// Call Macro
				// Call Macro: fase5()
				FCM_fase5();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase4()
{

	// Decision
	// Decision: sensA = 0?
	if (FCV_SENSA == 0)
	{

		// Decision
		// Decision: sensB > 0?
		if (FCV_SENSB > 0)
		{

			// Decision
			// Decision: sensC = 0?
			if (FCV_SENSC == 0)
			{

				// Call Macro
				// Call Macro: fase4()
				FCM_fase4();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase3()
{

	// Decision
	// Decision: sensA > 0?
	if (FCV_SENSA > 0)
	{

		// Decision
		// Decision: sensB > 0?
		if (FCV_SENSB > 0)
		{

			// Decision
			// Decision: sensC = 0?
			if (FCV_SENSC == 0)
			{

				// Call Macro
				// Call Macro: fase3()
				FCM_fase3();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase2()
{

	// Decision
	// Decision: sensA > 0?
	if (FCV_SENSA > 0)
	{

		// Decision
		// Decision: sensB = 0?
		if (FCV_SENSB == 0)
		{

			// Decision
			// Decision: sensC = 0?
			if (FCV_SENSC == 0)
			{

				// Call Macro
				// Call Macro: fase2()
				FCM_fase2();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}

/*=----------------------------------------------------------------------=*\
   Use :
\*=----------------------------------------------------------------------=*/
void FCM_cekfase1()
{

	// Decision
	// Decision: sensA > 0?
	if (FCV_SENSA > 0)
	{

		// Decision
		// Decision: sensB = 0?
		if (FCV_SENSB == 0)
		{

			// Decision
			// Decision: sensC > 0?
			if (FCV_SENSC > 0)
			{

				// Call Macro
				// Call Macro: fase1()
				FCM_fase1();

			// } else {

			}

		// } else {

		}

		// Decision
		// Decision: sensA > 0?
		if (FCV_SENSA > 0)
		{

			// Decision
			// Decision: sensB = 0?
			if (FCV_SENSB == 0)
			{

				// Decision
				// Decision: sensC > 0?
				if (FCV_SENSC > 0)
				{

					// Call Macro
					// Call Macro: fase1()
					FCM_fase1();

				// } else {

				}

			// } else {

			}

		// } else {

		}

	// } else {

	}

}



/*========================================================================*\
   Use :Main
\*========================================================================*/
int main()
{
	MCUSR=0x00;
	MCUSR=0x00;
	wdt_disable();


	// Call Component Macro
	// Call Component Macro: pwmSpeed::Enable()
	FCD_0df41_pwmSpeed__Enable();

	// Call Macro
	// Call Macro: fase1()
	FCM_fase1();

	// Loop
	// Loop: While 1
	while (1)
	{

		// Call Macro
		// Call Macro: getHallSensor()
		FCM_getHallSensor();


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/




